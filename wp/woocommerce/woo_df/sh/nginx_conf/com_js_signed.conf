# /www/server/nginx/conf/com_js_signed.conf
# 更可靠的 JavaScript 挑战（签名 Cookie）
# 依赖：OpenResty 自带 lua-nginx-module
#
# 使用说明：
# 1) 在 http { } 级别（nginx.conf 内）声明共享字典：
#      lua_shared_dict sc_token_store 10m;
# 2) 提供一个长随机密钥（32+ 长度），可通过：
#      - http {} 中：env SC_SECRET;
#      - 或在 server 块里：set $sc_secret "请替换为随机密钥";
# 3) 在需要保护的 server 块 include 本文件，替换旧的 com_js_plus.conf。
#
# 核心思路：
# - 浏览器访问受保护页面时，如无有效签名 Cookie，则返回到 @challenge。
# - @challenge 用 Lua 生成短期签名 Token 写入 Cookie（绑定 UA，30 分钟过期）。
# - 普通脚本/爬虫难以重现签名；偷来的 Cookie 窗口短且与 UA 绑定，价值低。
# - 仍保留搜索引擎、社交爬虫、静态资源放行。

# ============================================
# 默认需要挑战
# ============================================
set $need_challenge 1;
include /www/server/nginx/conf/com_secret.conf;
# ============================================
# 搜索引擎放行（防 UA 伪装）：仅对“疑似搜索引擎 UA”做反查验证
# 说明：
# - 仅凭 UA 放行很容易被伪造绕过
# - 这里对 Google/Bing 做 reverse DNS + forward confirm（并做缓存）
# - 未验证通过：继续走挑战（方案 A）
# ============================================
set $sc_suspected_se_bot 0;
# 为了尽可能避免误伤google的各种业务机器人(比如Google-InspectionTool等),这里用最宽松的关键词做匹配
# if ($http_user_agent ~* "google") {
if ($http_user_agent ~* "(Googlebot|Google-InspectionTool|Storebot-Google|GoogleOther|AdsBot-Google|Mediapartners-Google|FeedFetcher-Google|APIs-Google|Google-Read-Aloud)") {
    set $sc_suspected_se_bot 1;
}
# 对bing简单匹配即可
# if ($http_user_agent ~* "(Bingbot|BingPreview|msnbot|adidxbot)") {
if ($http_user_agent ~* "bing") {
    set $sc_suspected_se_bot 1;
}
# ============================================
# AI 爬虫弱校验放行（严格限速）
# 目标：允许常见 AI 爬虫抓取“几乎全站”，但避免被伪造 UA 获得高权限。
# 策略：
# - 仅 GET/HEAD 放行（POST 等仍走原逻辑/由应用处理）
# - 仅对非敏感路径放行（账户/结算/后台等仍保持挑战/拒绝）
# - 叠加严格限速（ai_limit）
# ============================================
set $is_ai_bot 0;
if ($http_user_agent ~* "(GPTBot|ChatGPT-User|OAI-SearchBot|OpenAI|PerplexityBot|ClaudeBot|Anthropic|cohere-ai|DuckAssistBot)") {
    set $is_ai_bot 1;
}
# 敏感路径：即使是 AI bot 也不弱放行（仍保留挑战/拒绝）
set $ai_allow 0;
if ($is_ai_bot = 1) {
    # 默认允许ai爬虫
    set $ai_allow 1;
}
# 对于敏感路径,则不允许ai爬虫(主要是防伪装的,虽然其他配置文件已经阻止了常见的敏感路径)
if ($request_uri ~* "^/(wp-admin/|wp-login\.php|xmlrpc\.php|account/|my-account/|cart/|checkout/)") {
    set $ai_allow 0;
}

# AI bot 只对 GET/HEAD 弱放行
if ($request_method !~ ^(GET|HEAD)$) {
    set $ai_allow 0;
}

# 开启弱放行：仅将 need_challenge 置 0 (建议叠加限速)
if ($ai_allow = 1) {
    set $need_challenge 0;
}


access_by_lua_block {
    if ngx.var.need_challenge ~= "1" then
        return
    end
    if ngx.var.sc_suspected_se_bot ~= "1" then
        return
    end

    local ip = ngx.var.remote_addr
    if not ip then
        return
    end

    local dict = ngx.shared.sc_bot_cache
    local cache_key = "vbot:" .. ip
    if dict then
        local v = dict:get(cache_key)
        if v == "1" then
            ngx.var.need_challenge = "0"
            return
        elseif v == "0" then
            ngx.header["X-SC-Block"] = "unverified_bot_cache"
            return ngx.exit(403)
        end
    end

    local resolver = require "resty.dns.resolver"
    local r, err = resolver:new({
        nameservers = { "1.1.1.1", "8.8.8.8" },
        retrans = 2,
        timeout = 2000,
    })
    if not r then
        if dict then dict:set(cache_key, "0", 60) end
        ngx.header["X-SC-Block"] = "unverified_bot_dns_init"
        return ngx.exit(403)
    end

    local function ends_with(s, suffix)
        return s and suffix and #s >= #suffix and s:sub(-#suffix) == suffix
    end

    local function resolve_ptr(ipaddr)
        local ans, e = r:reverse_query(ipaddr)
        if not ans then
            return nil
        end
        for _, rr in ipairs(ans) do
            if rr.type == r.TYPE_PTR and rr.ptrdname then
                return rr.ptrdname
            end
        end
        return nil
    end

    local function forward_has_ip(name, ipaddr)
        local ans, e = r:query(name, { qtype = r.TYPE_A })
        if ans then
            for _, rr in ipairs(ans) do
                if rr.address == ipaddr then
                    return true
                end
            end
        end
        local ans6, e6 = r:query(name, { qtype = r.TYPE_AAAA })
        if ans6 then
            for _, rr in ipairs(ans6) do
                if rr.address == ipaddr then
                    return true
                end
            end
        end
        return false
    end

    local ptr = resolve_ptr(ip)
    if not ptr then
        if dict then dict:set(cache_key, "0", 300) end
        ngx.header["X-SC-Block"] = "unverified_bot_no_ptr"
        return ngx.exit(403)
    end
    ptr = (ptr:gsub("%.$", ""))
    ngx.header["X-SC-PTR"] = ptr

    local ua = ngx.var.http_user_agent or ""
    local ual = string.lower(ua)
    local ok = false

    local is_google = (ual:find("google", 1, true) ~= nil)
    local is_bing = (ual:find("bing", 1, true) ~= nil) or (ual:find("msn", 1, true) ~= nil)

    if is_google then
        if ends_with(ptr, "googlebot.com") or ends_with(ptr, "google.com") then
            ok = forward_has_ip(ptr, ip)
        end
    elseif is_bing then
        if ends_with(ptr, "search.msn.com") then
            ok = forward_has_ip(ptr, ip)
        end
    else
        if ends_with(ptr, "googlebot.com") or ends_with(ptr, "google.com") then
            ok = forward_has_ip(ptr, ip)
        elseif ends_with(ptr, "search.msn.com") then
            ok = forward_has_ip(ptr, ip)
        end
    end

    if dict then
        dict:set(cache_key, ok and "1" or "0", ok and 21600 or 600)
    end
    if ok then
        ngx.var.need_challenge = "0"
        return
    end
    ngx.header["X-SC-Block"] = "unverified_bot"
    return ngx.exit(403)
}

# 社交媒体爬虫
if ($http_user_agent ~* "(facebookexternalhit|Twitterbot|LinkedInBot|Pinterest|WhatsApp|TelegramBot|Discordbot)") {
    set $need_challenge 0;
}

# 支付/监控服务
if ($http_user_agent ~* "(PayPal|Stripe|Shopify|UptimeRobot|Pingdom)") {
    set $need_challenge 0;
}

# ============================================
# 静态资源跳过验证
# ============================================
location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|webp|woff|woff2|ttf|eot|mp4|mp3|pdf|zip)$ {
    set $need_challenge 0;
    expires 30d;
    access_log off;
}

# ============================================
# Cookie 签名校验（sc2）
# 格式： sc2=时间戳_随机值_签名Base64
# 签名： MD5(secret|ts|nonce|ua)
# 过期： 1800 秒；未来 300 秒以内视为有效（允许时钟误差）
# 绑定： UA（不绑定 IP，避免代理换 IP 造成误伤）
# ============================================
set $sc2_ok 0;

# ============================================
# 受保护的页面（可按需调整前缀）
# ============================================
location ~ ^/(product|shop|category|cart|checkout|account|admin){
    access_by_lua_block {
        if ngx.var.need_challenge ~= "1" then
            return
        end

        -- 重要：location 级 access_by_lua 会覆盖 server 级 access_by_lua。
        -- 为避免搜索引擎拿到 200 的挑战页，这里对疑似 Google/Bing UA 再做一次验证。
        if ngx.var.sc_suspected_se_bot == "1" then
            local ip = ngx.var.remote_addr
            if not ip then
                ngx.header["X-SC-Block"] = "unverified_bot_no_ip"
                ngx.header["X-Robots-Tag"] = "noindex"
                return ngx.exit(403)
            end

            local dict = ngx.shared.sc_bot_cache
            local cache_key = "vbot:" .. ip
            if dict then
                local v = dict:get(cache_key)
                if v == "1" then
                    ngx.var.need_challenge = "0"
                    return
                elseif v == "0" then
                    ngx.header["X-SC-Block"] = "unverified_bot_cache"
                    ngx.header["X-Robots-Tag"] = "noindex"
                    return ngx.exit(403)
                end
            end

            local resolver = require "resty.dns.resolver"
            local r, err = resolver:new({
                nameservers = { "1.1.1.1", "8.8.8.8" },
                retrans = 2,
                timeout = 2000,
            })
            if not r then
                if dict then dict:set(cache_key, "0", 60) end
                ngx.header["X-SC-Block"] = "unverified_bot_dns_init"
                ngx.header["X-Robots-Tag"] = "noindex"
                return ngx.exit(403)
            end

            local function ends_with(s, suffix)
                return s and suffix and #s >= #suffix and s:sub(-#suffix) == suffix
            end
            local function resolve_ptr(ipaddr)
                local ans, e = r:reverse_query(ipaddr)
                if not ans then
                    return nil
                end
                for _, rr in ipairs(ans) do
                    if rr.type == r.TYPE_PTR and rr.ptrdname then
                        return rr.ptrdname
                    end
                end
                return nil
            end
            local function forward_has_ip(name, ipaddr)
                local ans, e = r:query(name, { qtype = r.TYPE_A })
                if ans then
                    for _, rr in ipairs(ans) do
                        if rr.address == ipaddr then
                            return true
                        end
                    end
                end
                local ans6, e6 = r:query(name, { qtype = r.TYPE_AAAA })
                if ans6 then
                    for _, rr in ipairs(ans6) do
                        if rr.address == ipaddr then
                            return true
                        end
                    end
                end
                return false
            end

            local ptr = resolve_ptr(ip)
            if not ptr then
                if dict then dict:set(cache_key, "0", 300) end
                ngx.header["X-SC-Block"] = "unverified_bot_no_ptr"
                ngx.header["X-Robots-Tag"] = "noindex"
                return ngx.exit(403)
            end
            ptr = (ptr:gsub("%.$", ""))
            ngx.header["X-SC-PTR"] = ptr

            local ua = ngx.var.http_user_agent or ""
            local ual = string.lower(ua)
            local ok = false

            local is_google = (ual:find("google", 1, true) ~= nil)
            local is_bing = (ual:find("bing", 1, true) ~= nil) or (ual:find("msn", 1, true) ~= nil)

            if is_google then
                if ends_with(ptr, "googlebot.com") or ends_with(ptr, "google.com") then
                    ok = forward_has_ip(ptr, ip)
                end
            elseif is_bing then
                if ends_with(ptr, "search.msn.com") then
                    ok = forward_has_ip(ptr, ip)
                end
            else
                if ends_with(ptr, "googlebot.com") or ends_with(ptr, "google.com") then
                    ok = forward_has_ip(ptr, ip)
                elseif ends_with(ptr, "search.msn.com") then
                    ok = forward_has_ip(ptr, ip)
                end
            end

            if dict then
                dict:set(cache_key, ok and "1" or "0", ok and 21600 or 600)
            end
            if ok then
                ngx.var.need_challenge = "0"
                return
            end

            ngx.header["X-SC-Block"] = "unverified_bot"
            ngx.header["X-Robots-Tag"] = "noindex"
            return ngx.exit(403)
        end

        local function is_obvious_non_browser()
            local ua = ngx.var.http_user_agent or ""
            if ua == "" then
                return true
            end
            local l = string.lower(ua)
            if l:find("curl", 1, true) or l:find("wget", 1, true) or l:find("python", 1, true) or l:find("requests", 1, true) or l:find("httpclient", 1, true) or l:find("go%-http%-client", 1, true) then
                return true
            end

            local h = ngx.req.get_headers(0, true)
            if not h["accept"] then
                return true
            end

            local has_sf = h["sec-fetch-site"] or h["sec-fetch-mode"]
            local has_ch = h["sec-ch-ua"]
            local has_u = h["upgrade-insecure-requests"]
            if not h["accept-language"] and not has_sf and not has_ch and not has_u then
                return true
            end

            return false
        end

        local function deny(reason)
            local m = ngx.req.get_method()
            if m == "GET" or m == "HEAD" then
                local u = ngx.var.request_uri or "/"
                if is_obvious_non_browser() then
                    ngx.status = 403
                    return ngx.exec("@challenge")
                end
                return ngx.redirect("/_sc/challenge?u=" .. ngx.escape_uri(u), 302)
            end
            return ngx.exit(403)
        end

        local cookie = ngx.var.http_cookie or ""
        local c = cookie:match("^%s*sc2=([^;]+)") or cookie:match(";%s*sc2=([^;]+)")
        if not c then
            return deny("no_cookie")
        end

        c = c:gsub("^%s+", ""):gsub("%s+$", "")
        c = c:gsub('^"', ""):gsub('"$', "")

        local ts, nonce, mac = c:match("^(%d+)_([0-9a-fA-F]+)_([0-9a-fA-F]+)$")
        if not ts then
            return deny("bad_format")
        end

        if #mac ~= 32 or #nonce < 6 or #nonce > 32 then
            return deny("bad_format")
        end

        ts = tonumber(ts)
        local now = ngx.time()
        if not ts or (now - ts) > 1800 or (ts - now) > 300 then
            return deny("expired")
        end

        local secret = ngx.var.sc_secret or os.getenv("SC_SECRET")
        if not secret or #secret < 16 then
            return deny("no_secret")
        end

        local data = secret .. "|" .. ts .. "|" .. nonce .. "|" .. (ngx.var.http_user_agent or "")
        local expected = ngx.md5(data)
        if expected ~= string.lower(mac) then
            return deny("mac_mismatch")
        end

        ngx.var.need_challenge = "0"
        ngx.var.sc2_ok = "1"
    }
    try_files $uri $uri/ /index.php?$args;
}

location = /__sc_verify {
    add_header Cache-Control "no-store";
    content_by_lua_block {
        if ngx.var.need_challenge ~= "1" then
            return ngx.exit(404)
        end

        local ts = tonumber(ngx.var.arg_ts or "")
        local nonce = ngx.var.arg_nonce or ""
        local proof = ngx.var.arg_proof or ""

        if not ts or nonce == "" or proof == "" then
            return ngx.exit(400)
        end
        if #nonce < 6 or #nonce > 32 or #proof ~= 32 then
            return ngx.exit(400)
        end

        local now = ngx.time()
        if (now - ts) > 60 or (ts - now) > 10 then
            return ngx.exit(403)
        end

        local sct = ngx.var.cookie_sct
        if not sct then
            return ngx.exit(403)
        end

        local tts, tnonce, tsig = sct:match("^(%d+)_([0-9a-fA-F]+)_([0-9a-fA-F]+)$")
        if not tts or not tnonce or not tsig then
            return ngx.exit(403)
        end
        if tonumber(tts) ~= ts or tnonce ~= nonce or #tsig ~= 32 then
            return ngx.exit(403)
        end

        local secret = ngx.var.sc_secret or os.getenv("SC_SECRET")
        if not secret or #secret < 16 then
            return ngx.exit(500)
        end

        local tdata = secret .. "|ticket|" .. ts .. "|" .. nonce .. "|" .. (ngx.var.http_user_agent or "")
        local texpect = ngx.md5(tdata)
        if texpect ~= string.lower(tsig) then
            return ngx.exit(403)
        end

        local jdata = tostring(ts) .. "|" .. tostring(nonce) .. "|" .. (ngx.var.http_user_agent or "")
        local jexpect = ngx.md5(jdata)
        if jexpect ~= string.lower(proof) then
            return ngx.exit(403)
        end

        local sc2_data = secret .. "|" .. ts .. "|" .. nonce .. "|" .. (ngx.var.http_user_agent or "")
        local mac = ngx.md5(sc2_data)

        local host = ngx.var.host or ""
        local base = host:match("([^.]+%.[^.]+)$")
        local domain_attr = ""
        if base and base ~= host then
            domain_attr = "; Domain=." .. base
        end

        local function is_client_https()
            local xfproto = (ngx.var.http_x_forwarded_proto or "")
            if xfproto == "https" then
                return true
            end
            local cfv = ngx.var.http_cf_visitor or ""
            if cfv:find('"scheme"%s*:%s*"https"') then
                return true
            end
            if ngx.var.scheme == "https" then
                return true
            end
            return false
        end

        local client_https = is_client_https()
        local same_site = client_https and "None" or "Lax"

        local cookie_sc2 = string.format("sc2=%d_%s_%s; Path=/; HttpOnly; SameSite=%s; Max-Age=1800%s", ts, nonce, mac, same_site, domain_attr)
        local cookie_sct = "sct=; Path=/; Max-Age=0; SameSite=" .. same_site .. domain_attr

        if client_https then
            cookie_sc2 = cookie_sc2 .. "; Secure"
            cookie_sct = cookie_sct .. "; Secure"
        end

        ngx.header["Set-Cookie"] = { cookie_sc2, cookie_sct }
        ngx.header["Content-Type"] = "text/plain; charset=utf-8"
        ngx.say("ok")
        return ngx.exit(200)
    }
}

# ============================================
# 挑战页：生成签名 Cookie 并刷新
# ============================================
location @challenge {
    internal;
    content_by_lua_block {
        -- 搜索引擎 UA 永远不应该拿到 200 的挑战页（避免被当作正文收录）
        if ngx.var.sc_suspected_se_bot == "1" then
            ngx.header["X-SC-Block"] = "se_challenge_block"
            ngx.header["X-Robots-Tag"] = "noindex"
            return ngx.exit(403)
        end

        ngx.status = 403

        -- 速率限制：同一 IP 60 次/分钟
        local dict = ngx.shared.sc_token_store
        if dict then
            local key = ngx.var.remote_addr or "0"
            local new, err = dict:incr(key, 1, 0, 60)
            if new and new > 60 then
                return ngx.exit(429)
            end
        end

        -- AI bot（弱校验放行策略的风险控制）：更严格的挑战速率限制
        -- 说明：AI bot 本身通常不会走挑战；这里主要用于限制“伪装 AI UA 反复触发挑战”的行为。
        if ngx.var.is_ai_bot == "1" and dict then
            local key2 = "ai:" .. (ngx.var.remote_addr or "0")
            local new2, err2 = dict:incr(key2, 1, 0, 60)
            if new2 and new2 > 30 then
                return ngx.exit(429)
            end
        end

        local secret = ngx.var.sc_secret or os.getenv("SC_SECRET")
        if not secret or #secret < 16 then
            ngx.status = 500
            ngx.say("SC secret missing")
            return
        end

        local now = ngx.time()
        local nonce = string.sub(ngx.md5(now .. ngx.var.request_uri .. (ngx.var.remote_addr or "") .. math.random()), 1, 12)
        local tdata = secret .. "|ticket|" .. now .. "|" .. nonce .. "|" .. (ngx.var.http_user_agent or "")
        local tsig = ngx.md5(tdata)

        local host = ngx.var.host or ""
        local base = host:match("([^.]+%.[^.]+)$")
        local domain_attr = ""
        if base and base ~= host then
            domain_attr = "; Domain=." .. base
        end

        local function is_client_https()
            local xfproto = (ngx.var.http_x_forwarded_proto or "")
            if xfproto == "https" then
                return true
            end
            local cfv = ngx.var.http_cf_visitor or ""
            if cfv:find('"scheme"%s*:%s*"https"') then
                return true
            end
            if ngx.var.scheme == "https" then
                return true
            end
            return false
        end

        local client_https = is_client_https()
        local same_site = client_https and "None" or "Lax"
        local cookie = string.format("sct=%d_%s_%s; Path=/; SameSite=%s; Max-Age=120%s", now, nonce, tsig, same_site, domain_attr)
        if client_https then
            cookie = cookie .. "; Secure"
        end

        ngx.header["Set-Cookie"] = { cookie }
        ngx.header["Content-Type"] = "text/html; charset=utf-8"
        ngx.header["Cache-Control"] = "no-store"
        ngx.header["X-Robots-Tag"] = "noindex"

        local f = io.open("/www/server/nginx/conf/js_challenge_openresty.html", "rb")
        if not f then
            ngx.status = 503
            ngx.say("challenge template missing")
            return
        end
        local body = f:read("*a")
        f:close()
        ngx.say(body)
    }
}

location = /_sc/challenge {
    add_header Cache-Control "no-store";
    access_by_lua_block {
        return ngx.exec("@challenge")
    }
}
